## 1. UTF-8 BOM 详解

**BOM(Byte Order Mark)** 是一个Unicode字符，用于标识文本文件或流中的Unicode编码类型。这是一个"零宽度非换行空格"字符，用来表示文本流的字节顺序。

在UTF-8中，BOM是一个可选的字节序列`EF BB BF`，可以出现在文本流的开始。然而，并不是所有的UTF-8文本都包含BOM，因为它在UTF-8中通常不是必需的。

在`Lexer::lexImpl`代码中，存在一个检查来看是否文件开始处有一个BOM，并且跳过它。这是因为BOM对于Radium源代码来说是不必要的，但如果存在，分析器应该知道如何处理它。


## 2. 关于Lexer.cc中的isValidIdentifierContinuationCodePoint和isValidIdentifierStartCodePoint函数的分析

这两个函数用于确定一个给定的 Unicode 代码点是否可以作为标识符的开始或继续字符。这是用于源代码处理的工具，如编译器或词法分析器，用于识别和验证源代码中的标识符。

1. **`isValidIdentifierContinuationCodePoint`函数**:

- **参数**: 接受一个`uint32_t c`，这是一个 Unicode 代码点。
- **功能**: 此函数检查给定的 Unicode 代码点是否为标识符的有效的继续字符。

- **详细说明**:

  1. 首先，函数检查代码点是否小于0x80，也就是说，它是否是一个 ASCII 字符。如果是，它使用`clang::isAsciiIdentifierContinue`函数来确定这个字符是否是标识符的合法字符。这个函数检查字符是否是一个 ASCII 字母、数字、下划线或美元符号。

  2. 如果代码点不是 ASCII 字符，函数接下来使用一系列的范围和特定的代码点检查，以确定代码点是否在 C 和 C++ 标准中为标识符继续字符推荐的 Unicode 范围内。这些范围来源于 N1518 提议，这是一个关于 C 和 C++ 扩展标识符字符的建议。
    
2. **`isValidIdentifierStartCodePoint`函数**:

- **参数**: 同样接受一个`uint32_t c`。
- **功能**: 此函数检查给定的 Unicode 代码点是否为标识符的有效的起始字符。

- **详细说明**:

  1. 使用`isValidIdentifierContinuationCodePoint`函数检查代码点是否是一个有效的标识符继续字符。如果不是，它立即返回`false`。
  
  2. 对于小于 0x80 的代码点（即 ASCII 字符），如果它是数字或美元符号，则返回`false`。这是因为标识符的第一个字符不应该是数字或美元符号。
  
  3. 函数再次引用 N1518 提议，这次是 Annex X.2，它提供了不应该作为标识符起始字符的代码点的范围。
    
- **为什么要这么写**:

  - 这两个函数之所以这么写，是为了确保给定的 Unicode 代码点是否遵循标识符的 C 和 C++ 标准规则。
  
  - 在许多编程语言中，标识符是由字母、数字和某些特殊字符（如下划线）组成的，但首字符不能是数字。这两个函数确保了这一规则在一个更大、更广泛的字符集（即 Unicode）中得到遵循。
  
  - 函数使用了多个范围检查来确定一个给定的代码点是否在一个特定的 Unicode 范围内。这样的检查是非常有效的，因为它们避免了使用复杂的数据结构或查找表，只需简单地使用范围比较即可。

总之，这两个函数是用来识别和验证标识符在源代码中的字符的，这对于词法分析、语法分析或其他源代码处理任务来说是非常关键的。